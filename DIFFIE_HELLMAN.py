#!/usr/bin/env python3
# cryptohack

import telnetlib
import json
import base64
import binascii
import Crypto.Util.number
from pwn import *
import codecs
import random
from Crypto.PublicKey import RSA

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import hashlib
import os

def neg_mod(a, mod):return mod - (a % mod)

def mul_mod(a, b, mod):
    return ((a % mod)*(b % mod)) % mod

#all by myself
def pow_mod(a, b, mod):
    #print(f"EVALUATING {a} ^ {b} mod {mod}\n--------------------------")
    a = mul_mod(a, 1, mod)
    return pow_mod1(a, b, mod, a)

def pow_mod1(a, b, mod, binpow):
    #print(f"\na= {a} b= {b} mod= {mod} binpow= {binpow}")
    b2 = b // 2
    k = b % 2
    #print(f"b2= {b2} k= {k}")
    if b == 0: return 1
    if b == 1: return binpow

    next_binpow = mul_mod(binpow ,binpow ,mod)
    #print(f"next_binpow= {next_binpow}")
    next_pow = pow_mod1(a, b2, mod, next_binpow)
    #print(f"next_binpow= {next_binpow} next_pow= {next_pow}")
    if k==1:
        result = mul_mod(binpow, next_pow, mod)
        #print(f"result = mul_mod(binpow, next_pow, mod) = {result}")
    else:
        result = next_pow
        #print(f"result = next_pow = {result}")
    #print(f"result== {result}")
    return result

#is quadratic residue
def isqr_mod(a, mod):
    result = False
    for i in range(mod):
        #print(f"i= {i} a= {a}")
        #print(f"i**2 mod({mod})= {mul_mod(i,i,mod)}   (-i)**2 mod({mod})= {mul_mod(neg_mod(i, mod),neg_mod(i, mod),mod)}")
        if mul_mod(i,i,mod) == a or mul_mod(neg_mod(i, mod),neg_mod(i, mod),mod) == a:
            #print(f"sqroot(a) mod {mod}= {i}")
            result = True
    return result

#Legendre's Symbol - modulo must be prime
def leg_mod(a, mod):
    return pow_mod(a,(mod-1)//2 ,mod)

def isqr_mod2(a, mod):
    if leg_mod(a, mod) == mod-1:
        return False
    return True



#Diffie-Hellman Starter 1
#-------------------------------------------------------------

#p = 991
#g = 209
#for i in range(p):
#    if(mul_mod(i, g, p)==1):
#        print(i)
#        break

#Diffie-Hellman Starter 2
#-------------------------------------------------------------

#p=28151

"""
for i in range(p):
    if i==0: continue

    powers=[]
    e=1
    print(f"p= {p} --- trying {i}")
    for j in range(p):
        e = mul_mod(e, i, p)
        #print(f"e={e} powers= {powers}")
        if e in powers: break
        powers+=[e]


    print(f"p= {p} len(powers)+1= {len(powers)+1}\n")
    if len(powers)==p-1:
        print(f"first primitive element = {i}")
        break
"""



#Diffie-Hellman Starter 3
#-------------------------------------------------------------

#kind of easy?
#g=2
#a=972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815
#p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
#print(pow(g,a,p))

#Diffie-Hellman Starter 4
#-------------------------------------------------------------

#not secret
#g=2
#not secret
#p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
#alice A=g**a mod p
#A=70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601
#my secret b
#b=12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720
#my generated B=g**b mod p (provided?)
#B=518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172
#print(B)
#print(pow(g,b,p))

#our shared secret will be (g**a)**b mod p
#our shared secret will be A**b mod p
#print(pow(A,b,p))

#Diffie-Hellman Starter 5
#-------------------------------------------------------------

"""
def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))


def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('ascii')
    else:
        return plaintext.decode('ascii')

#not secret
g=2
#not secret
p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
#alice A=g**a mod p
A=112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784
#my secret b
b=197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944
#my generated B=g**b mod p (provided?)
B=1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581
print(B)
print(pow(g,b,p))

#our shared secret will be (g**a)**b mod p
#our shared secret will be A**b mod p
shared_secret=pow(A,b,p)
iv = '737561146ff8194f45290f5766ed6aba'
ciphertext = '39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c'

print(decrypt_flag(shared_secret, iv, ciphertext))
"""

#MAN IN THE MIDDLE - Parameter Injection
#-------------------------------------------------------------
#alice -> me: g,p,A  i use my secret b calculating B=pow(g,b,p),K=pow(A,b,p)
#i need to send alice B after. my secret with alice is K
#me -> bob: g,p,A(B)
#bob -> me: B(B2) calculating K2=pow(B2,b,p)
#sending alice my B
#recieving and decrypting alice message

r = remote('socket.cryptohack.org', 13371, level = 'debug')

def json_recv():
    line = r.recvline()
    return json.loads(line.decode())

def json_send(hsh):
    request = json.dumps(hsh).encode()
    r.sendline(request)

def hex_decode(data):
    result = ""
    i = 0
    while i < len(data):
       result += chr(int(data[i:i+2], 16))
       i+=2
    return result

def encrypt_flag(FLAG,shared_secret: int):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Encrypt flag
    iv = os.urandom(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(pad(FLAG, 16))
    # Prepare data to send
    data = {}
    data['iv'] = iv.hex()
    data['encrypted_flag'] = ciphertext.hex()
    return data

def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))

def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('ascii')
    else:
        return plaintext.decode('ascii')

#print(encrypt_flag(shared_secret))

received = r.recvline()
received = received[24:]
#print(f"\nReceived: {received}")
data=json.loads(received.decode())
#print(f"\ndata= {data}")

#not secret
g=int(data["g"],16)
print(f" ***** g={g}")
#not secret
p=int(data["p"],16)
print(f" ***** p={p}")
#p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
#alice A=g**a mod p
A=int(data["A"],16)
print(f" ***** A={A}")
#A=112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784
#my secret b
b=197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944
#my generated B=g**b mod p (provided?)
B=1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581
#print(pow(g,b,p))
print(f"\n ***** B={B}")
#our shared secret will be (g**a)**b mod p
#our shared secret will be A**b mod p
K=pow(A,b,p)
print(f"\n ***** K={K}")

data2={"p": data["p"], "g": data["g"], "A": hex(B)}
request = json.dumps(data2).encode()
r.sendline(request)

received = r.recvline()
received = received[35:]
#print(f"\nReceived: {received}")
data=json.loads(received.decode())

B2=int(data["B"],16)
print(f" ***** B2={B2}")
K2=pow(B,b,p)
print(f" ***** K2={K2}")

#sending alice my B
data2={"B": hex(B)}
request = json.dumps(data2).encode()
r.sendline(request)

received = r.recvline()
received = received[39:]
print(f"\nReceived: {received}")
data=json.loads(received.decode())

print(decrypt_flag(K, data["iv"], data["encrypted_flag"]))

r.close()


